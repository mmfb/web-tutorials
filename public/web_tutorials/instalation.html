<html>

<head>
  <title>Node.js Web App</title>
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <link rel="stylesheet" href="../stylesheets/style.css">
  <script src="../javascripts/utils.js"></script>
</head>


<body onload='includeHtml("../header.html","header","..")'>
  <header id="header"></header>
  <main>
    <section>
      <h1> Objectives </h1>
      <ul class="objectives">
        <li> <input type="checkbox"> Understand the architecture of a restfull web application</li>
        <li> <input type="checkbox"> Installing node.js, express.js and other support modules</li>
        <li> <input type="checkbox"> Setting up localhost Node.js/Express.js application </li>
      </ul>
      <h2> Other objectives </h2>
      <ul class="objectives">
        <li><input type="checkbox"> Setting up a database on a Node.js/Express.js application </li>
        <li><input type="checkbox"> Using version control with git and github </li>
        <li><input type="checkbox"> Setting up a online Node.js/Express.js application using Cyclic hosting </li>
      </ul>
    </section>
    <section>
      <h1> Index </h1>
      <ol>
        <li>
          <a href="#restapp">The architecture of a restfull web application</a>
        </li>
        <li>
          <a href="#create_server">
            Creating a Node.js/Express.js project
          </a>
        </li>
        <li>
          <a href="#set_database">
            Configuring a database and using it
          </a>
        </li>
        <li>
          <a href="#deploy_cyclic">
            Setting up a website: Github and Cyclic
          </a>
        </li>
        <li>
          <a href="#creating_api">
            Creating different types of endpoints for our api
          </a>
        </li>

      </ol>
    </section>

    <section id="restapp">
      <h2>1- The architecture of a restfull web application</h2>
      <p>The following image will try to summarize all the components of a web application, their relations, and
        the corresponding resources/concepts.</p>
      <p class="centerImg"><img class="large" src="images/restfullapp.png"
          alt="Rest application architecture with node/express"></p>
      <h4 class="clickMe" onclick="showHide('archExplain',false,'block')">Click to tooggle the explanation of the
        image and of Web Applications concepts</h4>
      <section class="canHide" id='archExplain'>
        <ul>
          <li>
            <p>At the top right you see two IDE (Integrated Development Environment) used to create code and manage
              databases:
            </p>
            <ul>
              <li>
                <p><strong><a href=" o https://code.visualstudio.com/">Visual Studio Code</a></strong>
                  Editor for code, including all things web (
                  <a href="#html">HTML</a>, <a href="#css">CSS</a>,
                  <a href="#javascript">Javascript</a>, etc)
                </p>
                <p>You can also get Notepad++:
                <ul>
                  <li> It is also an editor for any type of text file </li>
                  <li> It is lighter and good for quick modifications</li>
                </ul>
                <a href="https://notepad-plus-plus.org/downloads/">https://notepad-plus-plus.org/downloads/</a>
                </p>
              </li>
              <li>
                <p><strong>Database Client Application</strong>

                  Applications to manage and develop databases, they will depend on the database used. Examples:
                </p>
                <ul>
                  <li>
                    <p><strong><a href="https://dev.mysql.com/downloads/workbench/">Workbench</a></strong>
                      Allows the design and management of MySql databases and similar </p>
                  </li>
                  <li>
                    <p><strong><a href="https://www.pgadmin.org/">pgAdmin</a></strong>
                      Open Source administration and development platform for PostgreSQL </p>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <p>Bellow the IDEs, connected to the DB Client you see the databases.
              This constitutes the base of the three tiers that usually constitute a web application:
              <strong>Database | Server | Client </strong>.
            </p>
            <p> For local server you can use a local or a remote database,
              but for an online server you will need a remote database,
              because it would be really hard to connect to the local server.</p>
          </li>
          <li>
            <p> In the top middle you see a depiction of the <a href="#node_express">Node.js/Express.js</a> server. The
              server is divided in two parts:
            <ul>
              <li><strong>Web Pages Server</strong>
                Will serve HTML, CSS, Javascript and other files (ex: images) to the browser clients
              </li>
              <li>
                <p><strong><a href="#rest">REST</a> API Server</strong>
                  Will serve data requested by web pages on the browser (using <a href="#ajax">AJAX</a>
                  and <a href="#json">JSON</a>) and could also serve data to
                  other applications (using JSON).</p>
                <p>
                  Since the REST API is responsible to manage data, only this part of the server will communicate with
                  the
                  database.
                </p>
              </li>
            </ul>
            </p>
          </li>
          <li>
            <p> In the top left side you see the client side:
            <ul>
              <li>
                <p><strong>Browser</strong>
                  Browsers like chrome, safari or edge will need web pages composed by HTML, CSS, images, etc.
                  All these files will be sent by the Web Pages Server.</p>
                <p> Some of these pages will also need data.
                  These pages will have javascripts that will request the data from the REST API Server
                  (the one that can obtain data from the Database) and insert that data on the web pages </p>
                <p>Some pages will also send data to the REST API also using javascript.</p>
              </li>
              <li>
                <p><strong>Apps</strong>
                  Applications like mobile applications or desktop programs can also comunicate with the server.
                </p>
                <p> Since applications will have their own interface they only need the data so they only connecto to
                  the
                  REST API Server.</p>
              </li>

            </ul>
            </p>
          </li>
          <li>
            <p> In the bottom, inside the cloud, you have a depiction of the online web server.
              It replicates the same elements as the local web server: clients,
              Node.js/Express.js server and database (the online database).
              The Node.js/Express.js server is divided in the same way in Web Page Server and REST API Server.
            </p>
            <p>
              To create an online server you need a provider.
              We give as example the <a href="#heroku">Cyclic</a> platform that suports Node.js servers and where you
              can easilly deploy applications from your public <a href="#github">github</a> repository.
            </p>
            <p>
              The idea is simple:
            <ol>
              <li>Create a local <a href="#git">git</a> repository that will allow us to manage versions and connect to
                a
                remote repository.</li>
              <li>Push the latest version to a remote git repository like <a href="github">
                  GitHub</a>.</li>
              <li>Connect your GitHub account with Cyclic and create an App that connects to a repository.
                After configuring this connection Cyclic will automatically deploy the latest version
                of the code each time the GitHub repository is updated.</li>
            </ol>
            </p>
            <p>
              You can see more details on how to deploy a Node Web Application on Cyclic on <a
                href="#deploy_cyclic">another section of this tutorial</a>.
            </p>


          </li>

        </ul>
        <h3>Other concepts and applications</h3>
        <ul>
          <li>
            <p id="node_express"><strong>Node.js and Express</strong>
              Allows for the creation of a server that will manage the requests and responses
              of web pages and other data. We will see this in more detail in this tutorial and following</p>
            <p><strong>Node.js </strong>
              Open source server environment (it is programmed in javascript)</p>
            <p>Reference: <a href="https://nodejs.org/en/docs/guides/">
                https://nodejs.org/en/docs/guides/ </a>
            <p>
            <p><strong> Express.js </strong>
              Node.js web application framework (it is a Node.js module), used to create web applications more easily
            </p>
            <p> References:
            <ul>
              <li>
                Routing:
                <a href="https://expressjs.com/en/starter/basic-routing.html">
                  https://expressjs.com/en/starter/basic-routing.html </a>
              </li>
              <li>
                API Reference:
                <a href="https://expressjs.com/en/4x/api.html">
                  https://expressjs.com/en/4x/api.html </a>
              </li>
            </ul>
            </p>

          </li>


          <li>
            <p id="html"><strong>HTML</strong>
              HypertText Modeling Language – Used to define the content of web pages</p>
            <p>Reference: <a href="https://www.w3schools.com/html/">
                https://www.w3schools.com/html/ </a>
              (w3schools is your "go to" resource for websites)</p>
          </li>
          <li>
            <p id="css"><strong>CSS</strong>
              Cascating Style Sheets – Used to describe the style (presentation) of the web pages</p>
            <p>Reference: <a href="https://www.w3schools.com/css">
                https://www.w3schools.com/css</a></p>
          </li>
          <li>
            <p id="javascript"><strong>Javascript</strong>
              Programming language for web development – Used to make calculations and modifications to and for your web
              pages
            <p>Reference: <a href="https://www.w3schools.com/js">
                https://www.w3schools.com/js</a></p>
          </li>
          <li>
            <p id="rest"><strong>REST</strong>
              REpresentational State Transfer (just a concept, nothing to install) - Defines a way to provide
              communication between computer systems.
              Applications that follow REST rules are called RESTfull Application</p>
            <p>Reference: <a href="https://www.restapitutorial.com/lessons/whatisrest.html">
                https://www.restapitutorial.com/lessons/whatisrest.html</a></p>
            <p>How to document a rest application: <a href="https://bocoup.com/blog/documenting-your-api">
                https://bocoup.com/blog/documenting-your-api</a></p>
          </li>
          <li>
            <p id="ajax"><strong>AJAX</strong>
              Asynchronous JavaScript And XML (just a concept, nothing to install) - Allows the communication of web
              pages
              with the server and dynamically updating the page without reloading the whole page (much more convenient
              than the other option).
              We will not use XML we will use JSON </p>
          </li>
          <li>
            <p id="json"><strong>JSON</strong>
              JavaScript Object Notation (just a concept, nothing to install) –
              A syntax for storing and exchanging data –
              We will use it to send and receive data between web pages and server </p>
            <p>Reference: <a href="https://www.w3schools.com/js/js_json_intro.asp">
                https://www.w3schools.com/js/js_json_intro.asp</a></p>
          </li>
          <li>
            <p id="git"><strong>Git</strong>
              Distributed version control system. Ables developer teams to manage several versions of code
              and colaboratively create applications.
              You can use it directly on a command line or using a client with a graphic interface.
            </p>
          </li>
          <li>
            <p id="github"><strong>GitHub</strong>
              It is a development platform – It is used to allow a community of developers to host and manage their
              code,
              including previous versions
            </p>
            <p>Reference: <a href="https://github.com/">
                https://github.com/</a></p>
          </li>
          <li>
            <p id="cyclic"><strong>Cyclic</strong>
              It is a PaaS (platform as a service) – We can use it to host our website (needs GitHub to get the code to
              deploy)
            </p>
            <p>Reference: <a href="https://www.cyclic.sh/">
                https://www.cyclic.sh/</a></p>
          </li>
        </ul>
      </section>
      <h3>What do you need to have</h3>
      <dl>
        <dt><strong>Install Node.js</strong></dt>
        <dd>
          <p>Site: <a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p>
          <p>Choose the LTS version (recommended for most users). Download and install Node.js.</p>
        </dd>
        <dt><strong>Install Visual Studio Code (Web Editor)</strong></dt>
        <dd>
          <p>Site: <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p>
          <p> When installing you have an option that will let you open a
            project folder directly from the explorer using right click (at least on windows).</p>
          <p class="clickMe" onclick="showHide('vscode_install',false,'block')"> Click to see an image of the VSCode
            instalation window</p>
          <p class="centerImg canHide" id="vscode_install""><img src=" images/vscode_install.png"
            alt="Node instalation window"></p>
          <p> When you first open a Node project VSCode will detect that it is a Node project
            and ask if you want to install extensions to help you. You can accept those.
            You can also install other extensions if you find them usefull.</p>
        </dd>
        <dt><strong>Install git</strong></dt>
        <dd>
          <p>Site: <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p>
          <p>The package will install the executables needed to run all git commands. ~
            You can call them using the terminal or install a git client. </p>
        </dd>
        <dt><strong>Install Postman</strong></dt>
        <dd>
          <p>Site: <a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a></p>
          <p> Although Postman is not needed to run the server, it is useful for testing.
            You can also use other programs for testing, including some VSCode extensions</p>
        </dd>
        <dt><strong>Create a Github account</strong></dt>
        <dd>
          <p>Site: <a href="https://github.com/">https://github.com/</a></p>
          <p> Select "Sign Up" and enter your account information.
            You will need a valid email since when you first login you will receive a code on your email
            that you need to write to enter. </p>
          <p> The first time you enter you will also be asked to create your first repository.
            Make it a public repository and give it a name (if you do not know what to call it, call it "myproject").
            If you already have an account create a new public repository instead.</p>
          <p> Create a README file when you create your repository (if you have not created you will always have
            an option to create it after). For now leave the README me as it is and click commit (you can change it
            later).</p>
        </dd>
        <dt><strong>Create a Cyclic account connected to your Github account</strong></dt>
        <dd>
          <p><strong>NOTE:</strong> You should only do this step after you created a basic Node.js/Express.js project.
            <a href="#create_server">See the section about creating a server</a>
          </p>
          <p>Site: <a href="https://cyclic.sh/">https://cyclic.sh/</a></p>
          <p> Choose "Sign Up" and then "Continue with Github". If you are already logged to github you only need
            to authorize the connection, otherwise you will ask you to login to your Github. </p>
          <p>You will then be asked to deploy your first App. We assume you already created your code
            on a github repository so you will need to choose the tab that says "Link Your Own".</p>
          </p>
          <p>
            Finally search for the repository name and click on it. Cyclic will retrieve all the information
            it needs from the Node.js configuration file (package.json).
          </p>
          <p>
            Check the next sections to see more of the available settings.
          </p>
        </dd>

      </dl>
      <dt><strong>Install a database and the database client</strong></dt>
      <dd>
        <p> You will need a database for your server.
          The database will not be a topic of this tutorial, only the connection to the database.</p>
        <p>Use the database that is required for your project. Two examples of commonly used databases:</p>
        <ul>
          <li><strong>MySql</strong>
            <p>Site: <a href="https://dev.mysql.com/downloads/workbench/">https://dev.mysql.com/downloads/workbench/</a>
            </p>
            <p>Should include MySql (database server) and Workbench (database client)</p>
          </li>
          <li><strong>PostgreSQL</strong>
            <p>Site: <a href="https://www.postgresql.org/download/">https://www.postgresql.org/download/</a></p>
            <p>Should include PostgreSQL (database server) and Pdadmin (dataabase client)
          </li>
        </ul>
      </dd>
      <dt><strong>Create a remote database</strong></dt>
      <dd>
        <p> You will need a remote database for your online server (server on Cyclic).</p>
        <p>Use the remote database that is required for your project. Examples of free database hosting for the
          two databases mentioned before:</p>
        <ul>
          <li><strong>MySql: Two options</strong>
            <p>Db4free: <a href="https://www.db4free.net/signup.php">https://www.db4free.net/signup.php</a></p>
            <p>RemoteMysql: <a href="https://remotemysql.com/login.php">https://remotemysql.com/login.php</a></p>
          </li>
          <li><strong>PostgreSQL</strong>
            <p>ElephantSQL: <a href="https://www.elephantsql.com/">https://www.elephantsql.com/</a></p>
        </ul>
        <p><strong>Warning: </strong>
          On free database hosting there can be downtime of the servers and your databases can be deleted without
          notice,
          specially if not being used for a long time or if they exceed the size limits.
          <strong>Always keep a copy</strong> of your database (scripts to create and populate) and <strong>before any
            presentation
            check</strong> if the database is working.
        </p>
      </dd>


    </section>

    <section id="create_server">
      <h2>2- Creating a Node.js/Express.js project</h2>
      <p>This section of the tutorial considerers that you already have the following setup:</p>
      <ul>
        <li>Node.js installed</li>
        <li>Git installed</li>
        <li>Visual Studio Code installed</li>
        <li>Github account created and repository created</li>
      </ul>
      <h3 class="clickMe" onclick="showHide('git_clone',false,'block')">Step 1: Clone your Github repository to your
        working directory (click to toggle text) </h3>
      <section id="git_clone">
        <p> First you need to configure your git username and email. These will be saved in every submission you make.
          Sugestion: Use the same email you used for Github and a name that can be recognized. </p>
        <p> Open a terminal. There is your computer's command line, but you also have the "git bash" (installed with
          git)
          and the "node.js command prompt" (installed with node). If for some reason git or node executables are not
          found they may still be used
          using the command line that comes with their installation. </p>
        <p> In the terminal run the following lines (with the name and email you want to use): </p>
        <pre><code class="language-bash">
          git config --global user.name "Your Name"
          git config --global user.email "youremail@yourdomain.com"
        </code></pre>
        <p> Now change directory to your working directory so that you can clone your Github repository to the correct
          place.
          Cloning will create a directory with the same name as the repository and with all code inside. </p>
        <p> Run the following code to clone (with your username and your project name):</p>
        <pre><code class="language-bash">
          git clone https://github.com/yourname/myproject
        </code></pre>
        <p> Since it is a public repository git will not ask you for authentication. With a private repository or
          when you try to submit changes to any repository you will need to authenticate with your user.</p>
        <p> Next we will learn the basics of git</p>


      </section>
      <h3 class="clickMe" onclick="showHide('git_management',false,'block')">Step 2: Basics of managing your git
        repository (click me to toggle text) </h3>
      <section id="git_management">
        <h4 class="clickMe" onclick="showHide('git_about',false,'block')">About Git (click to toggle text)</h4>
        <section class="canHide" id="git_about">
          <h4>2.1 What is git?</h4>
          <p> Git is a Version Control System (VCS). That means it saves versions of your project code allowing you to
            jump between different versions if you need to.</p>
          <p> Git was created for big projects with many contributers. It is a distributed system that allows several
            programmers to work on the same project and track each contribution individually.</p>
          <p> There are many approaches to VCS. Git considers its approach as snapshots of code.
            Every time a commit is made git will keep the full file if it is different from the previous version. If the
            file did not change it keeps a reference to that file.</p>
          <p> Other systems only keep a registry of changes (called a delta) of files that changed, which uses less
            space but spends
            more time when you want to retrive the file (since it needs to create the file from the deltas).</p>
          <h4>2.2 Local and remote repositores</h4>
          <p> Git is a distributed VCS. That means that each developer has his/her own version of
            the code in a local repository.</p>
          <p> Each developer will work on changes on the local repository and than push those changes to the remote
            repository available to all
            developers.
          </p>
          <ul>
            <li>When we make changes to the local repository we say that we <strong>commit</strong> the files.</li>
            <li>When we make changes to the remote repository we say that we <strong>push</strong> the files to the
              remote repository.
              Pushing will only work for commited files (see about git file stages in next topic)</li>
          </ul>
          <p> Developers can also pull the changes made by others to keep their local repository updated.
            In fact, <strong>you can only push the changes you made to the remote repository if you have the latest
              version of the remote
              repository</strong> i.e. you will need to pull changes made by other before pushing yours.</p>
          <h4>2.3 File stages in git</h4>
          <p> The git commands you can do depend on what stage your files are. Your files can pass by 4 stages:</p>
          <ul>
            <li> <strong>Modified</strong>. The file was edited but will not be commited before you mark the file to be
              part of the next commit.
              The local repository either does not have this file or has a older version. </li>
            <li> <strong>Staged</strong>. The file is not commited yet but it is marked to be commited in the next
              commit.</li>
            <li> <strong>Commited</strong>. Changes to the file were commited and the file is "up to date" on the local
              repository.
              The remote repository will not have these changes yet.</li>
            <li> <strong>Pushed</strong>. This means that you commited the changes to the remote repository, so the file
              is now "commited" on the remote repository too.
              Only changes that are commited on the local repository can be pushed. You can only push something if you
              your local repository has all the changes on the remote repository
              (otherwise you will need first to pull the changes from the remote repository).</li>
          </ul>
          <h4>2.4 Git commands for local repository</h4>
          <p> There are many commands you can use but we will focus only on the basic ones:</p>
          <ul>
            <li><strong>"git init"</strong> This creates a local repository. You will not need this command since "git
              clone" also creates a local repository
              that is a copy of the remote repository.</li>
            <li><strong>"git add . "</strong> Stages all files on the folder, including subfolders and their files. If
              you run this on the base folder
              of your project it will mark all files that were edited so that their changes are commited in the next
              commit.</li>
            <li><strong>"git commit"</strong> This will commit all changes, it will call the default editor for you to
              write a message describing the commit.
              <strong>All commits should have a description</strong>, the first line is a short description, the next
              lines describe in more details the changes made.
              If you have a short message to write you can add the message directly using <strong>git commit -m "Your
                message"</strong>.
              You can also change the default editor. The code bellow shows how to change to Notepad++ (default is Vim):
              <pre><code class="language-bash">git config --global core.editor "'C:/Program Files/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin"</code></pre>
            </li>
          </ul>
          <h4>2.5 Git commands for remote repository</h4>
          <p> We will again focus on the basic commands</p>
          <ul>
            <li><strong>" git clone https://github.com/yourname/myproject"</strong> This was the command we already
              used.
              It makes a copy of the remote repository to your computer. The created folder will have a local repository
              with all the commited changes.
              It will also save information about where the code came from, called the "remote", allowing you to pull
              changes or to push changes (if you are the owner of the remote or have permitions for it).</li>
            <li><strong>git remote add origin https://github.com/yourname/myproject</strong>
              You will not need to use this since "clone" already adds the information about the remote repository where
              the code came from.
              If you have created the local repository directly, for instance by using "git init", you will need to run
              this command to
              add your remote repository and push changes to it.
            </li>
            <li><strong>git push</strong> This will push all your commits to the remote repository (the ones not already
              there).
              It will only work if you have a remote configured, if you commited changes and if your local repository is
              up to date with the remote one (otherwise you need to make a pull first).
              You can also say the name of the remote and the branch where you want to push, but we will assume that you
              only have one remote and one branch.
            </li>
            <li><strong>git pull</strong> This will pull all the changes on the remote repository to your local
              repository (the ones that were not already there).
            </li>
          </ul>
          <h4>2.6 Conflicts</h4>
          <p>Consider the following example </p>
          <ol>
            <li> You made changes to the local repository </li>
            <li> Your colleague made changes to her/his local repository</li>
            <li> Your collegue pushed her/his changes to the remote repository</li>
            <li> You try to push yours and get an warning saying there are changes and that you need first to pull those
              changes</li>
            <li> You pull those changes to your computer</li>
          </ol>
          <p> Two things can occur when you pull the changes into your local repository where you already made some
            changes</p>
          <ol>
            <li>Git is able to merge both versions. This may be because changes were made in different files, or on
              different parts of the files.
              You can commit the merge to your local repository and than push the merged commit to the remote
              repository.
            </li>
            <li> Git finds a conflict between the two versions. Git will mark the conflict on those files by placing
              both versions of the changes~
              in the file with some aditional text to mark it. See an example bellow:
              <pre><code class="language-text">
              <<<<<<<<<< Head (Current Change)
                 Your code here
              ========
                 Your collaborator code here
              >>>>>>>>> Test (Incoming Change)
            </code></pre>
              You will need to edit the files with conflicts, choosing the correct code or creating a new code that
              correctly merges both.
              You also need to remove the added text. After that you can commit the merge and push. You have solved the
              conflict by manually making the merge.
          </ol>
        </section>
        <p> Enter the project folder that was created on the command line. </p>
        <p> Copy this file <a href="./files/gitignore">.gitignore</a> to your repository directory with the name
          ".gitignore" (make sure it has the dot in the beggining).
          The .gitignore file will tell git what files are not to be send to the repository. For instance the .env file
          will have sensitive
          information like our database password so we do not want it to be saved in the repository.</p>
        <p> You made changes to the repository so you need to run the commands to make the file go through all the
          necessary stages:
          Modified to Staged to Commited to Pushed. Run the following commands on the terminal inside your project
          folder:</p>
        <pre><code class="language-bash">
        git add .
        git commit -m "Added .gitignore for Node projects"
        git push
      </code></pre>
        <p> The push command will ask you to authenticate to your Github account. You only need to do this once, it will
          save the authentication for future interactions.</p>
        <p> You may need to use an access token instead of the Github password. It can be a little confusing so here are
          the steps for it:</p>
        <ol>
          <li> Login to you github account.</li>
          <li> Click on the top left icon (profile icon) and choose "Settings"</li>
          <li> On Settings scroll down and choose "Developer Settings"</li>
          <li> Then choose "Personal access tokens" and then "Tokens (classic)"</li>
          <li> Click on the link "Generate a personal access token" </li>
          <li> Fill in the details:
            <ul>
              <li><strong>Note</strong> Write a name to identify the token, for instance "git" </li>
              <li><strong>Select scopes</strong> Here you can define what the app can do with that token.
                Select "repo", that will allow git to access the repositories.</li>
            </ul>
          </li>
          <li>Scroll to the bottom and click "Generate token"</li>
          <li>Copy the token and paste it has a password (on some terminals you need to use right click to paste) to get
            access on git (Github username as username and the token as password)</li>
        </ol>
        <p> That is it, you made your first push and git now has credentials to access your github.
          You will not need to set the credentials again for that Github account, even for other projects/repositories.
        </p>
        <p>If you ever need to reset the credentials you need to open a terminal with administrator privelages and run
          this command:</p>
        <pre><code class="language-bash">git config --system --unset credential.helper</code></pre>
        <p>Now to test making a pull request. On your Github account edit the text on README.md (Github as an editor for
          that in the page).
          Change the text there to something like "My first Node app".
        </p>
        <p>Run "git pull" on the terminal to get the changes made online. </p>
        <p>Usually you will get the changes made by other developers but for them to change your code you need to add
          them has colaborators</p>
        <p> <strong>To add collaborators to your project/repository </strong>
          go to Settings on your repository and then to Collaborators</p>
        <p> Write the username of who you want to add. He will need to go to his email and accept the invitation.
          After accepting the repository will show on his Github account, even though the path still has the creator
          username.
          He will also be able to make pushes and pulls of the repository as if he was the owner.
        </p>
        <p> That is it, if you want you can try making more pulls and pushes with a collegue to get used to using git
          and Github.</p>
      </section>


    </section>
    <h3 class="clickMe" onclick="showHide('create_node',false,'block')">Step 3: Creating a Node.js/Express.js project
      (click me to toggle text) </h3>
    <section id="create_node">
      <h4 class="clickMe" onclick="showHide('node_about',false,'block')">About Node (click to toggle text)</h4>
      <section class="canHide" id="node_about">
        <h4>3N.1 What is Node?</h4>
        <p> Node.js was designed to build scalable network applications.
          Node.js focus on asynchronous and event base programming to prevent the main Node process from blocking or
          creating new threads.
        </p>
        <p> Basic example on how Node.js works:</p>
        <ul>
          <li> A node server receives a request.</li>
          <li> An asynchronous function call is made to process the request.</li>
          <li> The node server main process is released to accept other requests.</li>
          <li> When the funcion call finishes processing the request the main process is called again to send the result
          </li>
          <li> If no other requests are made the server will "sleep"</li>
        </ul>
        <h4>3N.2 What are the main parts of Node?</h4>
        <p> Node.js has a binary core and javascript modules. It also has a repository of modules made by third party.
        </p>
        <p> Some of the core elements of Node.js</p>
        <ul>
          <li><strong>libuv</strong> It is an important part of the binary core and provides network and file services.
          </li>
          <li><strong>V8</strong> Googles Javascript engine. Runs all the javascript code of the core and 3d party
            modules.
            The code we will create will also use the javascript language. </li>
          <li><strong> http module</strong> One of the core modules, it allows us to create a server.
            Some functionalities of Node.js are immediatly available, for other functionalities, like the ones on the
            http module,
            we first need to import the correct module </li>
          <li><strong> 3rd party modules</strong> Node.js includes a powerful
            package manager called NPM (Node Package Module). 3rd party companies can create modules and submit to the
            NPM repository,
            making that module easilly available to every developer</li>
        </ul>
        <p> Node.js has tried to avoid some of the mistakes made for the Javascript language.
          One example is that each module has its own namespace (named entities like variables and functions are only
          known in their module).
        </p>
        <p>This encapsulation of the module avoids conflicts of names that trouble many javascript projects.
          Each module can then define what is exported to the exterior.
          Only exported variable/functions will be available when we import the module.</p>
        <h4>3N.3 Basic commands and concepts of Node and NPM</h4>
        <p>We will present the basic commands in the order they are usually needed to create a new project </p>
        <ol>
          <li><strong>npm init</strong> This command will create a package.json file that contains the settings of a
            Node.js project.
            It has a command line user interface that will ask the information for the file creation.
            You can run the command without it asking questions using <strong>npm init -y</strong> it will use default
            values. </li>
          <li><strong>package.json</strong> It is a text file in JSON format (you can edit the file using any text
            editor)
            that contains the main settigns of a node project. You can see bellow a basic example of the contents:
            <pre><code class="language-json">              {
                "name": "myproject",
                "version": "1.0.0",
                "private": true,
                "scripts": {
                  "start": "node app.js"
                },
                "dependencies": {
                  "cookie-parser": "~1.4.4",
                  "dotenv": "^16.0.0",
                  "express": "~4.16.1",
                  "mysql2": "8.7.3"
                }
              }</code></pre>
            <p>First you have the name and version of the project. Version numbers have meanings "major.minor.patch"
              a working project will have at least a 1 on major. Minor means that the changes to the main version do not
              change the functionalities, and patches are only corrections.
            </p>
            <p> With private to true NPM will refuse the project if someone tries to send it to the repository by
              mistake</p>
            <p> The scripts define commands that can be called using NPM. <strong>npm start</strong> will run the code
              defined for the start script</p>
            <p> The dependencies mark the modules needed for the project. Each time you install a module it will be
              added to the dependencies.
              Installed modules are not sent to the Github repository, but anyone that clones the repository only needs
              to run <strong>npm install</strong>
              and all the dependencies in the package.json will be installed. Symbols like ~ ^ can be used to control
              which version of the module can be installed
              (^ means it can install newer versions as long as they still have the same major version i.e. the same
              first number) </p>
          </li>
          <li><strong>npm install</strong> If you run this line without naming a module it will install all dependencies
            on package.json.
            To install a specific module you can do <strong> npm install mysql2 --save</strong> this will
            install the "mysql2" module and with the --save option will also save the dependency on package.json.</li>
          <li><strong>node app.js</strong> After we install all modules we can run our project by calling the main
            script using node.
            Notice this is the same command we used on the start script on package.json, so this would do the same as
            running
            <strong>npm start</strong>
          </li>
          <li><strong>Stoping the server</strong> When the server starts the terminal will be used as a console for
            logging information.
            To terminate the server you can press <strong>Ctrl-C</strong> on the terminal </li>
        </ol>
      </section>
      <h4 class="clickMe" onclick="showHide('express_about',false,'block')">About Express (click to toggle text)</h4>
      <section class="canHide" id="express_about">
        <h4>3E.1 What is Express.js?</h4>
        <p> The express framework is a Node.js module that simplifies the creation of web applications.</p>
        <p> The main advantages of express consist on:</p>
        <ul>
          <li><strong>A routing system</strong> This system associates an handler to a pair HTTP-method + Path.
            This allows developers to create clear APIs, like REST APIs, to request resources (we will learn more about
            REST later).</li>
          <li><strong>Middleware system</strong> An express application is essentially a series of middleware that form
            a pipeline
            to handle requests. The user request is passed through a series of middleware that will add or change the
            information until
            the response is calculated and sent back. The middleware can be from express itself, from 3rd party modules
            or created by us</li>
          <li><strong>Template engines</strong> These engines provide a way to create responses from templates</li>
        </ul>
        <p> The express framework gained many adepts that integrated it with other systems.
          For instance the MEAN Full-stack Web Developmen System includes Mongo-DB (database), Express(server),
          Angular(client) and Node (server enviroment).
        </p>
        <h4>3E.2 Main Express.js functionalities</h4>
        <p> To use express we must first install if using NPM: <strong>npm install express --save</strong></p>
        <p> After that we can import the express module and create our servers. A simple example bellow:</p>
        <pre><code class="language-js">          const express = require("express");
          const app = express();
          var path = require('path');
          app.use(express.static(path.join(__dirname, 'public')));
          app.get("/api/", function (req, res) {
              res.send("Hello World!");
          });
          
          app.listen(8888, function () {
              console.log("Server running at http://localhost:8888");
          });</code></pre>
        <p><strong>require</strong> will import the express module and path module (parses path strings).</p>
        <p><strong>express()</strong> will create an object with the settings for an Node/Express
          application. We can define new settings on that object, determining how the application will work.</p>
        <p><strong>app.use(express.static(path.join(__dirname, 'public')));</strong>
          The public directory will now be used to look for static files (html, css, client javascript, images, etc)
          for our static web pages. __dirname is a global variable that nodes sets with the directory on where the
          project is,
          so by joining it with 'public' we mean the public folder inside our project directory.
        </p>
        <p><strong> app.get("/api/", function (req, res,next) {...}</strong>
          Defines a routing endpoint for the HTTP method <strong>get</strong> and path <strong>"/"</strong> and the
          defined handler.
          Handlers can receive 3 paramenters:
        </p>
        <ul>
          <li><strong>req</strong> Request object. Has all the information that the client sent to be processed.
            Some middleware adds more information to this request, for instance a cookie middleware can parse the cookie
            and had the
            parsed information to the request.</li>
          <li><strong>res</strong> Result object. We will fill this object with the information we want to send to the
            user.
            The object also has function like "send", that allow us to send the information on the request object back
            to the client.</li>
          <li><strong>next</strong> This is a function that allows you to pass the control to the next middleware.
            When the handler is the last middleware to be called we do not need the next function and we can simple
            write
            <strong> app.get("/", function (req, res) {...}</strong>
          </li>
        </ul>
        <p><strong>app.listen(8888, function () {...});</strong>
          The server starts and will be listening to request in the port 8888, the function passed as
          second argument will be called when the server starts.
        </p>


      </section>
      <h4 class="clickMe" onclick="showHide('servers_about',false,'block')"> How do servers work (click to toggle text)
      </h4>
      <section class="canHide" id="servers_about">
        <p> Consider a request of a website: </p>
        <p> <strong> http://www.mywebsite.pt:3000/folder1/mypage.html</strong></p>
        <p> The request will be composed of the following parts:</p>
        <ul>
          <li><strong>http</strong> The protocol. Defines the rules on how the communication is made</li>
          <li><strong>www.mywebsite.pt</strong> The domain name. This will allow to identify what computer/server the
            request is for.
            To identify which computer to send the resquest the domain name must first be converted to an IP address
            (Internet Protocol Address).
            The Domain Name System, a group of hierarchically connect computers, saves the information of what IP
            address
            corresponds to each domain name.</li>
          <li><strong>:3000</strong> The port. The same computer may have many servers running but different server can
            listen to different ports.</li>
          <li><strong>/folder1/mypage.html</strong> The path. A server may provide different information and services,
            the
            path will define what service/information to provide.</li>
          <li>The method. The HTTP protocol defines different methods of sending requests: GET,PUT, POST, DELETE,
            PATCH...
            When you write an address on a browser the method will be GET, that means "get" the information of the web
            page
            or data you need.
            For the same path the server can define different functionalities depending on the method used. The GET
            method
            may return data, while for the POST method we can have data being saved in the server</li>
        </ul>
      </section>
      <p>Create the package.json file by running <strong>npm init -y</strong> on the terminal (inside your project
        directory). We will edit the file later</p>
      <p>Install the modules we will need. Run the following commands:</p>
      <pre><code class="language-bash">
      npm install express --save
      npm install cookie-parser --save
      npm install dotenv --save
      npm install morgan --save
    </code></pre>
      <p> Besides the <strong>express</strong> module we are installing: </p>
      <ul>
        <li><strong>cookie-parers</strong> Parses the information of cookies. Cookies stored in files in the client
          side,
          each time the client requests information
          to the server the information in the cookie is sent, thus allowing to have a state that is not stored in the
          server side. The cookie information is stored in two variables on the request object (req). <br>
          <strong>req.cookies</strong> stores an object with all cookie information that is not signed.<br>
          <strong>req.signedCookies</strong> stores an object with all cookie information that was signed.<br>
          To be able to process signed cookies we need to set a string that will be the "secret" for the signature.
        </li>
        <li><strong>dot-env</strong> Creates a set of environment variables from a ".env" file.
          The ".env" file is not stored on the git repository, so this is usefull to keep password or other information
          that we do not wish to disclose to the repository.
          For example, we can use it to store the secret for signed cookies.</li>
        <li><strong>morgan</strong> This module will log information about requests to the terminal console. It is
          useful
          for debugging.</li>
      </ul>
      <p> Open the directory of the project with Visual Studio Code and then open the package.json file.
        You will see on the dependencies all the modules we installed.
      </p>
      <p> The node_modules directory was also created when you installed the modules. It will contain all installed
        modules.
        This directory will not be placed on the git repository. You can delete this directory at any time and just need
        to call
        <strong>npm install</strong> to create it again, since all dependencies are registered on the package.json file.
      </p>
      <p>
        Create a new file called <strong>index.js</strong> (this is the name of the main file in package.json) and write
        the code bellow:
      </p>
      <pre><code class="language-js">      require('dotenv').config();
      var express = require('express');
      var path = require('path');
      var cookieParser = require('cookie-parser');
      var morgan = require('morgan');
      
      var app = express();
      
      app.use(morgan('dev'));
      app.use(express.json());
      app.use(express.urlencoded({ extended: false }));
      app.use(cookieParser(process.env.COOKIE_SECRET));
      app.use(express.static(path.join(__dirname, 'public')));
      const port = parseInt(process.env.port || '8080');
      app.listen(port,function() {
        console.log("Server running at http://localhost:"+port);
      });</code></pre>
      <p> You also need to create a <strong>.env</strong> file (yes, the file must start with a dot in the beggining)
        where we will save the cookie secret.
        The file should have the line bellow inside</p>
      <pre><code class="language-text">      COOKIE_SECRET=This is a secret</code></pre>
      <p> Most of this code was already explained but we can make a summary:</p>
      <ul>
        <li>When running the command <strong> require('dotenv').config()</strong> we import all the enviroment variables
          in the <strong>.env</strong> file</li>
        <li> We import express module (require), create an express application (express()),
          configure the application (app.use(...)) and run the application (app.listen...).
          The port where the server runs can be changed by setting a PORT environment variable</li>
        <li>We set the morgan logger to print development information (prints for every request received)</li>
        <li>We configure the body parsers that come with express:
          <ul>
            <li><strong>express.json()</strong> Parses any json in the body of the request. The information will be
              stored
              in the request object as <strong>req.body</strong></li>
            <li><strong>express.urlencoded({ extended: false })</strong>
              Parses any urlencoded information in the body of the request.
              The information will be stored in the request object as <strong>req.body</strong></li>
          </ul>
          Body information can only be in one format so it will never overlap
        </li>
        <li>We configure the cookieParser with the secret that was stored in the .env file</li>
        <li>We defined the folder ('public') where our static files will be</li>
      </ul>
      <p>Now click on the terminal menu and then on "New Terminal". A terminal console will open bellow the code and you
        can run your code using the command
        <strong>node index.js</strong>
      </p>
      <p> At this moment any request you make will result in a "Not Found" error (HTTP error code 404), since we have no
        files in the public diretories and no routing defined.</p>
      <p> Create a "public" folder in the project and a index.html file inside with the code bellow</p>
      <div id="public_index"></div>
      <script>loadHTMLTextInto("files/index.html", "public_index");</script>
      <p>With an index.html file inside the public directory a page will open if you write "localhost:8080" on the
        browser.
        If no name is give the server will search for the "index.html" file.
      </p>
      <p> This was an example of the Node.js/Express.js web pages server (static pages). Now lets make an example of the
        REST API Server part.</p>
      <p> The REST API will serve data, and to keep the code organized we will create two new folders</p>
      <ul>
        <li>Create the <strong>routes</strong> folder. This folder will have code to receive requests, but will not make
          any calculations (no business logic).</li>
        <li>Create the <strong>models</strong> folder. This folder will have code to make all the needed calculations.
          When we have a database it will also be here we make the requests to the database.</li>
      </ul>
      <p> Create a <strong>usersRoutes.js</strong> file on the routes folder and
        a <strong>usersModel.js</strong> file on the models folder.</p>
      <p> Write the following code on the <strong>usersModel.js</strong> file:</p>
      <pre><code class="language-js">    class User {
      constructor(id,name,email,password) {
          this.id = id;
          this.name = name;
          this.email = email;
          this.password = password;
      }
  
      static async getAll() {
          try {
              let result = [];
              for(let user of users ){
                  result.push(new User(user.id,user.name,user.email));
              }
              return {status: 200, result: result};
          } catch (err) {
              console.log(err);
              return {status: 500, result: err };
          }
      }
  
  
  }
  
  const users = [
      new User(1,"John","john@mail.com", "123"),
      new User(2,"Mary","mary@m.pt","abc"),
      new User(3,"Bob","bob@mail.pt","god")
  ];
  
  module.exports = User;</code></pre>
      <h4 class="clickMe" onclick="showHide('user_model',false,'block')"> usersModel.js code explanation (click to
        toggle
        text)
      </h4>
      <section class="canHide" id="user_model">
        <h2>To Do</h2>
      </section>
      <p> Write the following code on the <strong>usersRoutes.js</strong> file:</p>
      <pre><code class="language-js">    const express = require('express');
    const router = express.Router();
    const User = require("../models/usersModel");
    
    router.get('/', async function(req, res, next) {
        try { 
            console.log("Get all users");
            let result = await User.getAll();
            res.status(result.status).send(result.result);
        } catch(err) {
            console.log(err);
            res.status(500).send(err);
        }
      });
    
    module.exports = router;
    </code></pre>

      <h4 class="clickMe" onclick="showHide('user_routes',false,'block')"> usersRoutes.js code explanation (click to
        toggle text)
      </h4>
      <section class="canHide" id="user_routes">
        <h2>To Do</h2>
      </section>
      <p> The route file will use the model file, but no file is yet connected to the server. We must include the routes
        in the application as an handler to an endpoint.</p>
      <p> On the <strong>index.js</strong> file add the two lines bellow after the definition of the static files
        directory (and before the line that makes the server listen to the 8080 port):</p>
      <pre><code class="language-js">
  const usersRouter = require("./routes/usersRoutes");
  app.use("/api/users",usersRouter);
  </code></pre>
      <p> This will mean that to access any routes in the usersRoutes file we will need to write "/api/users" in the
        path.
      </p>
      <p> Notice that in the routes we also set a path, so the full path will be first the "/api/users" and then the
        path
        on the route</p>
      <p> Since we first set the static file directory and then the routes, if a path matches a static file the server
        will send the static file
        and will not look at the routes.
        Only if no static file if found the routes are searched. That is why we placed the "/api/" for all the API
        routes.
        There will be no "api"
        folder inside the public folder, so the static files will not hide any of the API routes.
      </p>
    </section>
    <section id="set_database">
      <h2>3- Connecting to a database</h2>
      <p>This section of the tutorial considerers that you already have the following setup:</p>
      <ul>
        <li>Database installed (examples for MySql and PostgreSql)</li>
        <li>Some knowledge on how to use the database</li>
        <li>The server made on the <a href="#create_server">previous section</a></li>
      </ul>
      <h3 class="clickMe" onclick="showHide('create_database',false,'block')">Step 1: Create your database (click to
        hide)</h3>
      <section id="create_database">
        <p>First we need to create the database. Open your database client (ex: Workbench for MySql or pgadmin for
          PostgreSql).
          Open a tab to execute queries. Run the two next code examples:</p>
        <h4>Code to create the database and table</h4>
        <pre><code class="language-sql">create database mydb;

use mydb;

create table cards (
    crd_id int not null auto_increment,
    crd_name varchar(60) not null,
    crd_img_url varchar(200), -- what if we have more than one image?
    crd_lore varchar(400),
    crd_description varchar(300),
    crd_level int not null, -- cards of higher level cannot not be played in the beggining
    crd_cost int,
    crd_timeout int, -- while on timeout the card cannot be played
    crd_max_usage int, -- null means no max usage
    crd_type int not null,-- We should have another table defining what types exist
    -- If a card has multiple types we would need another table yet
	primary key (crd_id));</code></pre>
        <h4>Code to insert data into the table</h4>
        <pre><code class="language-sql">insert into cards (crd_name, crd_img_url, crd_lore, crd_description, crd_level, crd_cost, crd_timeout, crd_max_usage, crd_type)
values ('Left','left.png',null,'Move left',1,1,null,null,1); 
            
insert into cards (crd_name, crd_img_url, crd_lore, crd_description, crd_level, crd_cost, crd_timeout, crd_max_usage, crd_type)
values ('Full Ahead','fullA.png',"Full speed ahead! C'mon you lazy sea monkeys! - said captain Rust.",
'Move double space forward',2,1,2,2,1);             </code></pre>
        <p> You should also create a new folder on your project named <strong>db_scripts</strong>
          and save the previous code in two new files inside the folder:</p>
        <ul>
          <li> <strong>create.sql</strong> with the code to create the database and table</li>
          <li> <strong>populate.sql</strong> with the code to populate the database</li>
        </ul>
        <p> This way you can save the code to recreate the database. This code will also be sent to the repository.
          It is ok because this is just for learning, otherwise the database could have private data and we could not
          send it to the repository.
        </p>
      </section>
      <h3 class="clickMe" onclick="showHide('create_connection',false,'block')">Step 2: Connect to the database (click
        to hide)</h3>
      <section id="create_connection">
        <p>To connect to a database we first need to install the node module that is specific for our database
          (<strong>you should only install one database module</strong>):</p>
        <ul>
          <li>
            <p>Mysql has two possible modules: <strong>mysql</strong> and <strong>mysql2</strong>.
              We will be using <strong>mysql2</strong> since it should have a better performance
              and offers some additional features, in particular buitin support to promises.</p>
            <p>Just run <strong>npm install mysql2 --save</strong> inside your project folder</p>
          </li>
          <li>
            <p>PostgreSql Node.js module is simply called <strong>pg</strong> </p>
            <p>Just run <strong>npm install pg --save</strong> inside your project folder
          </li>
        </ul>
        <p>Now we need to set up the module in our project with the database settings.</p>
        <p> Since we do not want the settigns to be public on the repository (specially the password)
          we will use enviroment variables. Add the following lines to your <strong>.env</strong> file:
        </p>
        <pre><code class="language-text">DB_HOST=localhost
DB_USER=root
DB_PASS=root
DB_NAME=mydb</code></pre>
        <p><strong>DB_USER</strong> must be your user. <strong>root</strong> is the default user created for mysql,
          for postgresql the default user is <strong>postgres</strong>, so <strong>if you are using posgresql you
            will need to change the user to postgres</strong>.</p>
        <p><strong>DB_PASS</strong> must be the password you choosed for your database</p>
        <p><strong>DB_HOST</strong> and <strong>DB_NAME</strong> are the host name and the name of the database.
          Since we are running the database on the same computer as the server we used <strong>localhost</strong>
          and<strong>mydb</strong> was the name we gave to our database when we created it </p>
        <p> Next we create a new folder <strong>config</strong> to hold all files related with our server
          configurations.
          Inside create the <strong>database.js</strong> file with the following code: </p>
        <h5 onclick="showHide('con_mysql','con_postgres','block')">For Mysql (click to hide/show):</h5>
        <pre id="con_mysql"><code class="language-js">const mysql = require("mysql2/promise");

  const pool = mysql.createPool({
      host: process.env.DB_HOST,
      user: process.env.DB_USER,
      password: process.env.DB_PASS,
      database: process.env.DB_NAME,
      connectionLimit: 20});
  
  module.exports = pool;</code></pre>
        <h5 onclick="showHide('con_postgres','con_mysql','block')">For PostgreSql (click to show/hide):</h5>
        <pre style="display:none" id="con_postgres"><code class="language-js">const pg = require('pg');

  const Pool = pg.Pool
  const pool = new Pool({
      host: process.env.DB_HOST,
      user: process.env.DB_USER,
      password: process.env.DB_PASS,
      database: process.env.DB_NAME,
      max: 20});
  
  module.exports = pool;</code></pre>
        <h4 class="clickMe" onclick="showHide('db_con',false,'block')"> database.js code explanation (click to toggle
          text)
        </h4>
        <section class="canHide" id="db_con">
          <h2>To Do</h2>
        </section>
      </section>
      <h3 class="clickMe" onclick="showHide('create_db_code',false,'block')">
        Step 3: Create the code that uses the database (click to hide)</h3>
      <section id="create_db_code">
        <p> We will now create a new set of endpoints for the new resource (cards resource). </p>
        <p> To keep the code separated we create new files for new resources, keeping the endpoints for
          each resource on its own files (to learn more about organizing your API learn about REST APIs).</p>
        <p> Create a new <strong>cardsRoutes.js</strong> file and <strong>cardsModel.js</strong> file in their
          respective folders.</p>
        <p> The <strong>cardsModel.js</strong> file will use the database connection we created. See the code bellow:
        </p>
        <h5 onclick="showHide('cards_model_mysql','cards_model_postgres','block')"><strong>cardsModel.js</strong> code
          for Mysql (click to hide/show):</h5>
        <pre id="cards_model_mysql"><code class="language-js">const pool = require("../config/database");

          function cardFromDB(dbObj) {
              return new Card(dbObj.crd_id,dbObj.crd_name, 
                  dbObj.crd_img_url, dbObj.crd_lore, dbObj.crd_description,
                  dbObj.crd_level, dbObj.crd_cost, dbObj.crd_timeout,
                  dbObj.crd_max_usage, dbObj.crd_type);    
          }
          class Card {
              constructor(id,name,url,lore,description, level, 
                          cost, timeout, maxUsage, type) {
                  this.id = id;
                  this.name = name;
                  this.url = url;
                  this.lore = lore;
                  this.description = description;
                  this.level = level;
                  this.cost = cost;
                  this.timeout = timeout;
                  this.maxUsage = maxUsage;
                  this.type = type;
              }
          
              static async getAll() {
                  try {
                      let result = [];
                      let [dbCards,fields] = await pool.query("Select * from cards");
                      for(let dbCard of dbCards ){
                          result.push(cardFromDB(dbCard));
                      }
                      return {status: 200, result: result};
                  } catch (err) {
                      console.log(err);
                      return {status: 500, result: err };
                  }
              }          
          }
          
          module.exports = Card;</code></pre>
        <h5 onclick="showHide('cards_model_postgres','cards_model_mysql','block')"><strong>cardsModel.js</strong> code
          for PostgreSql (click to show/hide):</h5>
        <pre style="display:none" id="cards_model_postgres"><code class="language-js">const pool = require("../config/database");

          function cardFromDB(dbObj) {
            return new Card(dbObj.crd_id,dbObj.crd_name, 
                dbObj.crd_img_url, dbObj.crd_lore, dbObj.crd_description,
                dbObj.crd_level, dbObj.crd_cost, dbObj.crd_timeout,
                dbObj.crd_max_usage, dbObj.crd_type);    
          }
          class Card {
              constructor(id,name,url,lore,description, level, 
                          cost, timeout, maxUsage, type) {
                  this.id = id;
                  this.name = name;
                  this.url = url;
                  this.lore = lore;
                  this.description = description;
                  this.level = level;
                  this.cost = cost;
                  this.timeout = timeout;
                  this.maxUsage = maxUsage;
                  this.type = type;
              }
          
              static async getAll() {
                  try {
                      let result = [];
                      let dbres = await pool.query("Select * from cards");
                      let dbCards = dbres.rows;
                      for(let dbCard of dbCards ){
                        result.push(cardFromDB(dbCard));
                      }
                      return {status: 200, result: result};
                  } catch (err) {
                      console.log(err);
                      return {status: 500, result: err };
                  }
              }
          }
          
          module.exports = Card;</code></pre>
        <h4 class="clickMe" onclick="showHide('cards_model',false,'block')"> cardsModel.js code explanation (click to
          toggle
          text)
        </h4>
        <section class="canHide" id="cards_model">
          <h2>To Do</h2>
        </section>
        <p> The <strong>cardsRoutes.js</strong> file is almost identical to the one we made for
          usersRoutes.js. This is intended, since the idea is for Routes and Models to be independent
          modules, so changing the way the Model works should not affect the Routes.
          <strong>The Routes code is independent of the database you use</strong>. See the code bellow:
        </p>
        <h5 onclick="showHide('cards_routes',false,'block')"><strong>usersModel.js</strong> code (click to hide/show):
        </h5>
        <pre id="cards_model_mysql"><code class="language-js">const express = require('express');
          const router = express.Router();
          const Card = require("../models/cardsModel");
          
          router.get('/', async function(req, res, next) {
              try { 
                  console.log("Get all cards");
                  let result = await Card.getAll();
                  res.status(result.status).send(result.result);
              } catch(err) {
                  console.log(err);
                  res.status(500).send(err);
              }
            });
          
          module.exports = router;</code></pre>
        <h4 class="clickMe" onclick="showHide('cards_routes_exp',false,'block')"> cardsRoutes.js code explanation (click
          to toggle
          text)
        </h4>
        <section class="canHide" id="cards_routes_exp">
          <h2>To Do</h2>
        </section>
        <p>Finally, like before, we need to connect the new routes to the application.
          Add the following lines to the <strong>index.js</strong> file. </p>
        <pre><code class="language-js">const cardsRouter = require("./routes/cardsRoutes");
app.use("/api/cards",cardsRouter);</code></pre>
        <p>Keep your code organized. It is easier to read the code if you first do all the requires
          and then use them. So you should have something like this in your <strong>index.js</strong>: </p>
        <pre><code class="language-js">const usersRouter = require("./routes/usersRoutes");
const cardsRouter = require("./routes/cardsRoutes");

app.use("/api/users",usersRouter);
app.use("/api/cards",cardsRouter);</code></pre>
        <p>Restart the server and call the new endpoint: <a
            href="http://localhost:8080/api/cards">http://localhost:8080/api/cards</a></p>
      </section>
      <p> Now update your local and remote repository, you will need them updated to deploy your application on a remote
        host.</p>
    </section>
    <section id="deploy_cyclic">
      <h2>4- Setting up a website: Github and Cyclic</h2>
      <p>This section of the tutorial considerers that you already have the following setup:</p>
      <ul>
        <li>Created the code of a Node.js/Express.js application on the
          <a href="#set_database"> previous section</a> and have that code on your Github repository.
        </li>
        <li>Have the database scripts to create the database on a remote database host</li>
        </li>
      </ul>
      <h4>Set up the remote database</h4>
      <p> First you need to have a remote database. Use one of the free webhostings to create a remote database:</p>
      <ul>
        <li><strong>MySql: Two options</strong>
          <p>Db4free: <a href="https://www.db4free.net/signup.php">https://www.db4free.net/signup.php</a></p>
          <p>RemoteMysql: <a href="https://remotemysql.com/login.php">https://remotemysql.com/login.php</a></p>
        </li>
        <li><strong>PostgreSQL</strong>
          <p>ElephantSQL: <a href="https://www.elephantsql.com/">https://www.elephantsql.com/</a></p>
      </ul>
      <p> Usually database webhosts have a way for you to run sql commands but if you cannot find it
        you can always connect to the webhost using your database client and the database settings
        that you got when you created the database.</p>
      <p> Run the commands on your <strong>create.sql</strong> and <strong>populate.sql</strong> scripts
        on the remote host. For the create script <strong>you should only run the create table</strong>
        the database is already created and you cannot change the name</p>
      <p> Test the remote database by changing the database variables on your <strong>.env</strong>
        file with the settings you got when creating the database.
        After restarting the server your application should run exactly the same way with the remote database.</p>
      <p>You can change between the local and remote database at any time by changing the variables and restarting the
        server.</p>
      <h4>Deploy your application on Cyclic</h4>
      <p>First you need an account. Go to the Cyclic web page and choose to create the Free account:
        <a href="https://www.cyclic.sh/pricing">https://www.cyclic.sh/pricing</a>. Next steps:
      </p>
      <ul>
        <li>Press start on the free account.</li>
        <li>Choose to connect using Github (it is the only option) it will go to the github login page.</li>
        <li>If you are already logged on to your Github account in the browser it will ask you to authorize Cyclic
          access to the repository.
          If are not loggend on than you will need to fill your Github login username (or email) and password, and then
          you will be asked for authorization for Cyclic</li>
        <li>You now have a Cyclic account. Since you have no app yet on the account you will be asked to deploy your
          first app.</li>
        <li> Cyclic can create a basic code template for a server. Since we already have the code click on the
          <strong>Link Your Own</strong> tab.
        </li>
        <li> Click on the entrybox to search for the repository, choose the name of the repository and click it.</li>
        <li> If the project is a valid Node.js project it will show you a button to connect. Click the button to create
          your online web application.
          Github will ask you for your permission to connect to that repository.
        </li>
        <li>Your app is now online, but you may still want to finish some setups.
          <ul>
            <li> If you are using environment variables Cyclic will detect those variables
              and add them to enviroment variables setup page. It will also show you a warning with a direct link to
              that page.</li>
            <li>Click on the link and fill those variable values with the same values you have on your local server.
              For the database you will need the values for the remote database, in case you already changed them back
              to the local database
              (the local database can only be used by your local server). The "port" variable you can leave it empty
            </li>
            <li>Click the save button on the bottom.</li>
          </ul>
        </li>
        <li>Your app is now configured and running. The window you see is your App dashboard.
          Here you have many usefull information in different tabs, like the history of deploys
          (<strong>Deployments</strong> tab) or the <strong>Logs</strong>
          tab with all the "console.log" made by your code (same as what you would see in the terminal).</li>
        <li> In the top right you can also see the links for the running web application and the Github repository.
          <strong>Press the link for the application and test it</strong>. Do not forget that to test de cards endpoint
          you need to add "/api/cards" to the path.
        </li>
      </ul>
      <p>Eact time you update your repository code Cyclic will be informed of the changes and deploy
        the new version. If you wish to submit changes to your repository and not affect cyclic you will
        need to use two branches:
      </p>
      <ol>
        <li> Development branch where you can have the newest version of the code, even if unstable</li>
        <li> The main branch that will always have a stable version and that it is connected to Cyclic</li>
      </ol>
      <p> You can see more about branches in this tutorial: <a
          href="http://https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging">https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging</a>
    </section>
    <section id="creating_api">
      <h2>5- Creating different types of endpoints for our api</h2>
      <p>This section of the tutorial considerers that you already have the following setup:</p>
      <ul>
        <li>Created a the code of a Node.js/Express.js application on the
          <a href="#set_database"> this section (setup a database section)</a>
        </li>
        <li><strong>(not mandatory but advised)</strong> Have deployed the application on Cyclic <a
            href="#deploy_cyclic">(previous section)</a></li>
      </ul>
      <p> So far we only created a "get all" rule that will return all the cards on our table.
        Let us create some more endpoints and learn more about the functionalities of Express and of the database
        module. </p>
      <p> The functionalities we are going to see:</p>
      <ol>
        <li> Get one card given the id</li>
        <li>Insert a new card</li>
        <li> Get a list of cards with only cards of a given type </li>
        <li> Get a list of cards with a text on the lore or the description </li>
        <li>Edit a card</li>
        <li>Delete a card given the id</li>
      </ol>
      <p> Unlike the previous "get all" endpoint these endpoints will need information from the client side.
        This information is sent on the requests and can be send in 3 formats: </p>
      <ul>
        <li><strong> Path variables: /api/cards/1 </strong> The value is send as part of the path.
          This means we will have routes where the part has a variable, which is marked with ":", like
          this: <strong>/api/cards/:id</strong>. Inside the code we will be able to access the value from
          the request parameters (req.params) and using the name after the ":" like this <strong>req.params.id</strong>
        </li>
        <li><strong> The body of the message</strong> Get rules have no body, but rules to add or modify information,
          post and put rules respectively, will have a body with the information that will de added or changed.
          Like we talked in the beggining the <strong>body-parser</strong> module will parse any information sent in the
          body
          and save it in "req.body". If the client sent somethint like this:
          <pre><code class="language-json">{"name":"Up", "level":1}</code></pre>
          We can access both values using <strong>req.body.name</strong> and <strong>req.body.level</strong>.
          If we call only <strong>req.body</strong> we will have an object with both parameters.
        </li>
        <li><strong>Query parameters: /api/cards?type=1</strong> Path variables are the way to go if we want to obtain a
          specific resource,
          But if we want to filter a set of elements using some restrictions path variables are not the best choice.
          In this case query parameters are more flexible and make more sense. For instance, for the given example
          (/api/cards?type=1) the
          resource we want to obtain is the list of cards, but we want to filter to have only the ones of type 1.
          Query parameters are not part of the route path and are automatically parsed by express. For this example we
          could access the value
          by using <strong>req.query.type</strong>. We can have many parameters together (ex:
          <strong>/api/cards?levelMin=2&levelMax=5</strong>) and like for the req.body
          we can access them individualy (ex: <strong>req.query.levelMin</strong> and
          <strong>req.query.levelMax</strong>) or obtain an object
          with all the parameters inside (<strong>req.query</strong>).
        </li>
      </ul>
      <p>Next we will see the functionalities we mentioned before. For each we will need to add code on the
        <strong>card model file</strong> and on the <strong>card route file</strong>. However, <strong>we do not need
          to add code to the index.js file</strong> since the route file is already connected to the application (all
        new
        endpoints will be connected like the old ones). Since we are changing the server we will <strong>need to restart
          the server for any change to apply</strong>.
      </p>
      <h3 class="clickMe" onclick="showHide('get_card_by_id',false,'block')">
        Functionality 1: Get Card by Id (click to hide)</h3>
      <section id="get_card_by_id">
        <p> For this functionality we will need to receive the id of the card to get on the path, pass that id to the
          model
          to retrieve the card from the database, and return the information. If the received id is not valid the card
          will
          not be found and a 404 error will be returned.</p>
        <p> Another difference is that <strong>we return only one object</strong>, instead of a list.
          Since there is only one entity with that id <strong>it makes no sense to return a list</strong>.
          We need to do this server side since all calls to the database will always return a list of results, even when
          we
          only have one element on the list. </p>
        <p> The code bellow must be added to the <strong>cardsModel.js</strong> file:</p>
        <h5 onclick="showHide('card_id_model',false,'block')"><strong>Get card by id</strong> model code for mysql (click to
          hide/show):</h5>
        <pre id="card_id_model"><code class="language-js">    static async getById(id) {
          try {
              let [dbCards,fields] = 
                  await pool.query("Select * from cards where crd_id=?",[id]);
              if (!dbCards)
                  return {status:404, result: {msg: "No card found with that identifier"}};
              let dbCard = dbCards[0];
              let result = cardFromDB(dbCard);
              return {status: 200, result: result};
          } catch (err) {
              console.log(err);
              return {status: 500, result: err };
          }
      }</code></pre>
        
      <p><strong>ATTENTION:</strong> Notice we did not use the value of the id received from the client in our query.
      Instead we placed a "?" and then added a second parameter which is a list with the id inside.
    When we use "?" and the list the mysql2 module will replace the "?" by values in the list (same order) but those values will be escaped.
  Escaping values assures us that the value will be not be considered an SQL command, avoiding <strong>SQL Injection attacks</strong>
 (for instance the user could send "1; drop table card" as the id).</p>
 <p><strong>For PostgreSql</strong> instead of "?" we must use "$1","$2"...  The advantage is that you do not need to place the
values in the list in the order that they will appear in the sql command, since you control which position to use. 
You can even use the same position twice or more (placing two "$2" for instance).</p>
      <p> The code bellow must be added to the <strong>cardsRoutes.js</strong> file:</p>
        <h5 onclick="showHide('card_id_routes',false,'block')"><strong>Get card by id</strong> routes code (click to
          hide/show):</h5>
        <pre id="card_id_routes"><code class="language-js">  router.get('/:id', async function(req, res, next) {
        try { 
            console.log("Get card with id "+req.params.id);
            let result = await Card.getById(req.params.id);
            res.status(result.status).send(result.result);
        } catch(err) {
            console.log(err);
            res.status(500).send(err);
        }
      });</code></pre>
        <h4 class="clickMe" onclick="showHide('card_by_id',false,'block')"> <strong>Card by id</strong> model and route
          code explanation (click to toggle text)
        </h4>
        <section class="canHide" id="card_by_id">
          <h2>To Do</h2>
        </section>
      </section>
      <h3 class="clickMe" onclick="showHide('post_save_card',false,'block')">
        Functionality 2: Save a Card (click to hide)</h3>
      <section id="post_save_card">
        <p> For this functionality we have a post rule instead of a get rule.
          We also will need to receive information in the body.</p>
        <p>Before saving information in the database it is a good idea to verify the data that was sent.
          Remember that <strong>even if you make verifications in the client side you need to do them in the server side
            since client side code can always be bypassed</strong></p>
         <p> On the server side you can make verifications on the routes or on the models:</p>
         <ul><li> Route side verifications can make direct verifications of values, for instance checking if the
          field is empty or if it is an email</li>
            <li> Model side verifications can make more complex verifications that involve the database. 
              For instance if with had a table with all possible types we could check if the sent type corresponds to a valid type. </li></ul>
        <p> <strong>NOTE:</strong> It is hard to make a strong argument to where a validation should take place:</p>
        <ul><li>We can consider it business logic and place it on the model side.</li>
        <li>We can consider it a simple parameter validation
          and do it on routes. In this case we still need to use model functions to check for things like if a type exists or not.</li></ul>
        <p>In this tutorial, and our advice unless there are reasons otherwise, we decided to place all
          verifications that require the database inside the model, to avoid extra calls to the model.</p>
        <p>We also decided to make all simple parameter validations on the routes. This decision was made because we can use the
          <strong>express-validator</strong> module to make many of the verifications. This module will use the information on the request, 
        and we do not want to make the request available inside of the model.</p>
        <p> We will format the model side errors the same way that express-validator formats the errors, but there will be one difference.
          The express-validation route side verifications will group all errors and send them together, not making any model-side verification 
          if any error is found on the route side. On the model side verification we only send one error, since we will exit as soon as we find an error.
          Since verifications that involve the database will usually be more expensive we will avoid making verifications if we already know there is an error. 
        The disavantage is that the client will not know of all the errors of the request that was made, so even if the errors that were marked are corrected 
      the next request may receive a response with other errors, but only errors that needed validation from the database, since all "simple" errors are validated in group.</p>

        <p> So first we need to install the <strong>express-validator</strong> module:</p>
        <pre><code class="language-bash">npm install express-validator --save</code></pre>
        <p> You can see the documentation of the <strong>express-validator</strong> module <a href="https://express-validator.github.io/docs/">here</a>.</p>

        <p> The code bellow must be added to the <strong>cardsModel.js</strong> file:</p>
        <h5 onclick="showHide('card_id_model',false,'block')"><strong>Save card</strong> model code for mysql (click to
          hide/show):</h5>
        <pre id="card_id_model"><code class="language-js">    static async save(newCard) {
          try {
              let [dbCards, fields] =
                  await pool.query("Select * from cards where crd_name=?", [newCard.name]);
              if (dbCards.length)
                  return {
                      status: 400, result: [{
                          location: "body", param: "name",
                          msg: "That name already exists"
                      }]
                  };
              let [result] =
                  await pool.query(`Insert into cards (crd_name, crd_img_url, crd_lore, 
                  crd_description, crd_level, crd_cost, crd_timeout, crd_max_usage, crd_type)
                  values (?,?,?,?,?,?,?,?,?)`, [newCard.name, newCard.url, newCard.lore,
                  newCard.description, newCard.level, newCard.cost, newCard.timeout,
                  newCard.maxUsage, newCard.type]);
              return { status: 200, result: result };
          } catch (err) {
              console.log(err);
              return { status: 500, result: err };
          }
      }</code></pre>
        <p> The code bellow must be added to the <strong>cardsRoutes.js</strong> file:</p>
        <h5 onclick="showHide('save_card_routes',false,'block')"><strong>Save card</strong> routes code (click to
          hide/show):</h5>
        <pre id="save_card_routes"><code class="language-js">const { body, validationResult } = require('express-validator');
          router.post("/", 
              body('name').isLength({ min: 4, max: 60 })
                  .withMessage('Name must have between 4 and 60 characters'),
              body('level').isInt({ min: 0 })
                  .withMessage('Level must be a non negative integer number'),
              body('type').isInt({ min: 1 })
                  .withMessage('Type must be a positive integer number'),
              async function (req, res, next) {
                  try {
                      console.log("Save card with name " + req.body.name);
          
                      const valid = validationResult(req);
                      if (!valid.isEmpty()) {
                          return res.status(400).json(valid.array());
                      }
                      let result = await Card.save(req.body);
                      res.status(result.status).send(result.result);
                  } catch (err) {
                      console.log(err);
                      res.status(500).send(err);
                  }
              });</code></pre>
        <h4 class="clickMe" onclick="showHide('save_card',false,'block')"> <strong>Save_card</strong> model and route
          code explanation (click to toggle text)
        </h4>
        <section class="canHide" id="save_card">
          <h2>To Do</h2>
        </section>
      <p> Since browsers only do GET requests you will need to use Postman to test this endpoint.
          You will need to send information in JSON format. Try to test with some invalid data also to check if the
          validations are working. </p>
          <p>The image bellow shows an example of a test of the post endpoint in postman: </p>
          <p class="centerImg"><img class="big" src="images/post_cards_postman.png"
            alt="Postman example of testing the post cards endpoint"></p>
      
      </section>
      
    </section>
  </main>
  <script>hljs.highlightAll();</script>
</body>

</html>